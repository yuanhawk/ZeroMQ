<?xml version="1.0" encoding="utf-8"?>
<doc>
<assembly><name>fszmq</name></assembly>
<members>
<member name="P:fszmq.ZMQError.ErrorNumber">
<summary>
 the ZeroMQ-defined, or OS-defined, error code
</summary>
</member>
<member name="T:fszmq.ZMQError">
<summary>
 Represents any error raised by the native ZMQ library,
 with a human-readable summary in the Message property
</summary>
</member>
<member name="T:fszmq.Capability.Unknown">
<summary>
 Test for capability failed; support status is unknown
</summary>
</member>
<member name="T:fszmq.Capability.Supported">
<summary>
 Test passed; `yesOrNo` is true when `name` is supported
</summary>
</member>
<member name="T:fszmq.Capability">
<summary>
 Report if the underlying (native) ZMQ library supports a named capability
</summary>
</member>
<member name="T:fszmq.Version.Unknown">
<summary>
 Unable to determine versioning info
</summary>
</member>
<member name="T:fszmq.Version.Version">
<summary>
 Components of native versioning info
</summary>
</member>
<member name="T:fszmq.Version">
<summary>
 Report the version of the underlying (native) ZMQ library
</summary>
</member>
<member name="P:fszmq.Context.Handle">
<summary>
 For internal use only
</summary>
</member>
<member name="M:fszmq.Context.#ctor">
<summary>
 Initializes a new Context instance
</summary>
</member>
<member name="T:fszmq.Context">
<summary>
 Represents the container for a group of sockets in a node
</summary>
</member>
<member name="P:fszmq.Socket.Handle">
<summary>
 For internal use only
</summary>
</member>
<member name="T:fszmq.Socket">
<summary>
 An abstraction of an asynchronous message queue,
 with the exact queuing and message-exchange
 semantics determined by the socket type
</summary>
</member>
<member name="P:fszmq.Message.Handle">
<summary>
 For internal use only
</summary>
</member>
<member name="M:fszmq.Message.#ctor">
<summary>
 Creates a new empty Message
</summary>
</member>
<member name="M:fszmq.Message.#ctor(System.Byte[])">
<summary>
 Creates a new Message from the given byte array
</summary>
</member>
<member name="T:fszmq.Message">
<summary>
 Provides a memory-managed wrapper over ZMQ message operations
</summary>
</member>
<member name="T:fszmq.ZMQEventDetails.Unknown">
<summary>
 Received unknown (likely garbage) event data. Recheck your code.
</summary>
</member>
<member name="T:fszmq.ZMQEventDetails.MonitorStopped">
<summary>
 Monitoring on the given socket ended
</summary>
</member>
<member name="T:fszmq.ZMQEventDetails.Disconnected">
<summary>
 Raised when the socket was disconnected unexpectedly; 
 Carries the file descriptor of the underlying socket (validity no guaranteed)
</summary>
</member>
<member name="T:fszmq.ZMQEventDetails.CloseFailed">
<summary>
 Raise when the socket failed to close;
 Carries the error generated during the system call
</summary>
</member>
<member name="T:fszmq.ZMQEventDetails.Closed">
<summary>
 Raised when the socket was closed; 
 Carries the file descriptor of the underlying socket (validity no guaranteed)
</summary>
</member>
<member name="T:fszmq.ZMQEventDetails.AcceptFailed">
<summary>
 Raise when the socket has rejected a connection from a remote peer;
 Carries the error generated during the system call
</summary>
</member>
<member name="T:fszmq.ZMQEventDetails.Accepted">
<summary>
 Raised when the socket has accepted a connection from a remote peer; 
 Carries the file descriptor of the underlying socket (validity no guaranteed)
</summary>
</member>
<member name="T:fszmq.ZMQEventDetails.BindFailed">
<summary>
 Raise when the socket could not bind to a given interface;
 Carries the error generated during the system call
</summary>
</member>
<member name="T:fszmq.ZMQEventDetails.Listening">
<summary>
 Raised when the socket was successfully bound to a network interface; 
 Carries the file descriptor of the underlying socket (validity no guaranteed)
</summary>
</member>
<member name="T:fszmq.ZMQEventDetails.ConnectRetried">
<summary>
 Raised when a connect request failed, and is now being retried; 
 Carries the reconnect interval in milliseconds
</summary>
</member>
<member name="T:fszmq.ZMQEventDetails.ConnectDelayed">
<summary>
 Raised when a connect request on the socket is pending
</summary>
</member>
<member name="T:fszmq.ZMQEventDetails.Connected">
<summary>
 Raised when the socket has successfully connected to a remote peer; 
 Carries the file descriptor of the underlying socket (validity no guaranteed)
</summary>
</member>
<member name="T:fszmq.ZMQEventDetails">
<summary>
 Provides more-granular information about a ZMQEvent
</summary>
</member>
<member name="P:fszmq.ZMQEvent.Details">
<summary>
 Further information (event specific)
</summary>
</member>
<member name="P:fszmq.ZMQEvent.Address">
<summary>
 Specifies the endpoint of the monitored socket
</summary>
</member>
<member name="P:fszmq.ZMQEvent.EventID">
<summary>
 Identifies an individual socket-lifetime event
</summary>
</member>
<member name="T:fszmq.ZMQEvent">
<summary>
 Encapsulates data generated by various ZMQ monitoring events
</summary>
</member>
<member name="M:fszmq.PollingExtensions.TryGetInput(fszmq.Socket,System.Int64,System.Byte[][]@)">
<summary>
 Polls the given socket, up to the given timeout, for an input message.
 Retuns true if input was received, in which case the message is assigned to the out parameter.
</summary>
</member>
<member name="M:fszmq.PollingExtensions.AsPollOut(fszmq.Socket,System.Action{fszmq.Socket})">
<summary>
 Creates a Poll item for the socket which will
 invoke the callback when the socket receives a message
</summary>
</member>
<member name="M:fszmq.PollingExtensions.AsPollIn(fszmq.Socket,System.Action{fszmq.Socket})">
<summary>
 Creates a Poll item for the socket which will
 invoke the callback when the socket receives a message
</summary>
</member>
<member name="M:fszmq.PollingExtensions.AsPollIO(fszmq.Socket,System.Action{fszmq.Socket})">
<summary>
 Creates a Poll item for the socket which will
 invoke the callback when the socket sends or receives a message
</summary>
</member>
<member name="T:fszmq.PollingExtensions">
<summary>
 Utilities for working with Polling from languages other than F#
</summary>
</member>
<member name="T:fszmq.Poll.Poll">
<summary>
 Creates a new poll item, associating the given events, socket, and callback
</summary>
</member>
<member name="M:fszmq.Poll.Create(System.Int16,fszmq.Socket,System.Action{fszmq.Socket})">
<summary>
 Creates a poll item in a way friendly to languages other then F#
</summary>
</member>
<member name="T:fszmq.Poll">
<summary>
 For use with the Polling module...

 Associates a callback with a Socket instance and one or more events,
 such that the callback is invoked when the event(s) occurs on the Socket instance

 ** Note: all sockets passed to Polling.poll MUST share the same context
 and belong to the thread calling Polling.poll **
</summary>
</member>
<member name="M:fszmq.CapabilityExtensions.TryGetInfo(fszmq.Capability,System.String@,System.Boolean@)">
<summary>
 Extracts the details of the capability,
 returning true on success and false if capability info is unavailable
</summary>
</member>
<member name="M:fszmq.CapabilityExtensions.Match(fszmq.Capability,System.Action{System.String,System.Boolean},System.Action)">
<summary>
 Executes the appropriate callback based on availability of capability info
</summary>
</member>
<member name="M:fszmq.CapabilityExtensions.Match``1(fszmq.Capability,System.Func{System.String,System.Boolean,``0},System.Func{``0})">
<summary>
 Executes the appropriate callback based on availability of capability info
</summary>
</member>
<member name="M:fszmq.CapabilityExtensions.IfKnown(fszmq.Capability,System.Action{System.String,System.Boolean})">
<summary>
 Executes the given callback only if capability information is available
</summary>
</member>
<member name="T:fszmq.CapabilityExtensions">
<summary>
 Utilities for working with Capabiity from languages other than F#
</summary>
</member>
<member name="M:fszmq.VersionExtensions.TryGetInfo(fszmq.Version,System.Int32@,System.Int32@,System.Int32@)">
<summary>
 Extracts the details of the version,
 returning true on success and false if version info is unavailable
</summary>
</member>
<member name="M:fszmq.VersionExtensions.Match(fszmq.Version,System.Action{System.Int32,System.Int32,System.Int32},System.Action)">
<summary>
 Executes the appropriate callback based on availability of version info
</summary>
</member>
<member name="M:fszmq.VersionExtensions.Match``1(fszmq.Version,System.Func{System.Int32,System.Int32,System.Int32,``0},System.Func{``0})">
<summary>
 Executes the appropriate callback based on availability of version info
</summary>
</member>
<member name="M:fszmq.VersionExtensions.IfKnown(fszmq.Version,System.Action{System.Int32,System.Int32,System.Int32})">
<summary>
 Executes the given callback only if version information is available
</summary>
</member>
<member name="T:fszmq.VersionExtensions">
<summary>
 Utilities for working with Version from languages other than F#
</summary>
</member>
<member name="M:fszmq.ProxyingExtensions.SteerableProxy(fszmq.Socket,fszmq.Socket,fszmq.Socket,fszmq.Socket)">
<summary>
 creates a proxy connection passing messages between two sockets,
 with a third socket for PAUSE/RESUME/TERMINATE control
 and a fourth socket for supplemental data capture (e.g. logging)
</summary>
</member>
<member name="M:fszmq.ProxyingExtensions.SteerableProxy(fszmq.Socket,fszmq.Socket,fszmq.Socket)">
<summary>
 creates a proxy connection passing messages between two sockets,
 with a third socket for PAUSE/RESUME/TERMINATE control
</summary>
</member>
<member name="M:fszmq.ProxyingExtensions.Proxy(fszmq.Socket,fszmq.Socket,fszmq.Socket)">
<summary>
 creates a proxy connection passing messages between two sockets,
 with a third socket for supplemental data capture (e.g. logging)
</summary>
</member>
<member name="M:fszmq.ProxyingExtensions.Proxy(fszmq.Socket,fszmq.Socket)">
<summary>
 creates a proxy connection passing messages between two sockets
</summary>
</member>
<member name="T:fszmq.ProxyingExtensions">
<summary>
 Utilities for working with Polling from languages other than F#
</summary>
</member>
<member name="T:fszmq.ZMQ.SocketType">
<summary>
 Distinguishes socket roles from other intergral values
</summary>
</member>
<member name="P:fszmq.ZMQ.TERMINATE">
<summary>
 Command used to cleanly shutdown a steerable proxy
</summary>
</member>
<member name="P:fszmq.ZMQ.RESUME">
<summary>
 Command used to resume a suspended steerable proxy
</summary>
</member>
<member name="P:fszmq.ZMQ.PAUSE">
<summary>
 Command used to temporarily suspend a steerable proxy
</summary>
</member>
<member name="P:fszmq.ZMQ.FOREVER">
<summary>
 indicates polling should wait indefinitely
</summary>
</member>
<member name="P:fszmq.ZMQ.NOW">
<summary>
 indicates polling should exit immediately
</summary>
</member>
<member name="P:fszmq.ZMQ.POLLERR">
<summary>
 poll for messages on stderr (for use with file descriptors)
</summary>
</member>
<member name="P:fszmq.ZMQ.POLLOUT">
<summary>
 poll for outbound messages
</summary>
</member>
<member name="P:fszmq.ZMQ.POLLIN">
<summary>
 poll for inbound messages
</summary>
</member>
<member name="P:fszmq.ZMQ.NOBLOCK">
<summary>
 Deprecated. Use ZMQ.DONTWAIT
</summary>
</member>
<member name="P:fszmq.ZMQ.SNDMORE">
<summary>
 More message frames will follow the current frame
</summary>
</member>
<member name="P:fszmq.ZMQ.DONTWAIT">
<summary>
 Queue message frame for sending (return immediately)
</summary>
</member>
<member name="P:fszmq.ZMQ.WAIT">
<summary>
 Block thread until message frame is sent
</summary>
</member>
<member name="P:fszmq.ZMQ.SHARED">
<summary>
 (Int32) 1 indicates that a message MAY share underlying storage, 0 otherwise
</summary>
</member>
<member name="P:fszmq.ZMQ.SRCFD">
<summary>
 (IntPtr) The file descriptor of the socket from which the &apos;message&apos; was read
</summary>
</member>
<member name="P:fszmq.ZMQ.MORE">
<summary>
 (Int32) 1 if more message frames are available, 0 otherwise
</summary>
</member>
<member name="P:fszmq.ZMQ.ROUTER_BEHAVIOR">
<summary>
 Deprecated. Use ZMQ.ROUTER_MANDATORY
</summary>
</member>
<member name="P:fszmq.ZMQ.FAIL_UNROUTABLE">
<summary>
 Deprecated. Use ZMQ.ROUTER_MANDATORY
</summary>
</member>
<member name="P:fszmq.ZMQ.DELAY_ATTACH_ON_CONNECT">
<summary>
 Deprecated. Use ZMQ.IMMEDAITE
</summary>
</member>
<member name="P:fszmq.ZMQ.ROUTER_RAW">
<summary>
 Deprecated. Use ZMQ.STREAM socket instead
</summary>
</member>
<member name="P:fszmq.ZMQ.IPC_FILTER_GID">
<summary>
 Deprecated. Do not use.
</summary>
</member>
<member name="P:fszmq.ZMQ.IPC_FILTER_UID">
<summary>
 Deprecated. Do not use.
</summary>
</member>
<member name="P:fszmq.ZMQ.IPC_FILTER_PID">
<summary>
 Deprecated. Do not use.
</summary>
</member>
<member name="P:fszmq.ZMQ.TCP_ACCEPT_FILTER">
<summary>
 Deprecated. Do not use.
</summary>
</member>
<member name="P:fszmq.ZMQ.IPV4ONLY">
<summary>
 Deprecated. Do not use.
</summary>
</member>
<member name="P:fszmq.ZMQ.NO_LINGER">
<summary>
 (Int32) the value needed to disable lingering on a socket&apos;s outbound queue
</summary>
</member>
<member name="P:fszmq.ZMQ.SECURITY_GSSAPI">
<summary>
 Indicates GSSAPI security mechanism is currently in use
</summary>
</member>
<member name="P:fszmq.ZMQ.SECURITY_CURVE">
<summary>
 Indicates CURVE security mechanism is currently in use
</summary>
</member>
<member name="P:fszmq.ZMQ.SECURITY_PLAIN">
<summary>
 Indicates PLAIN security mechanism is currently in use
</summary>
</member>
<member name="P:fszmq.ZMQ.SECURITY_NULL">
<summary>
 Indicates there is currently no security mechanism in use
</summary>
</member>
<member name="P:fszmq.ZMQ.XPUB_NODROP">
<summary>
 (Int32) 0 drops the message silently when the peers SNDHWM is reached, 1 returns an &apos;EAGAIN&apos; error code (if ZMQ_DONTWAIT was used)
</summary>
</member>
<member name="P:fszmq.ZMQ.SOCKS_PROXY">
<summary>
 (String) SOCKS5 proxy
</summary>
</member>
<member name="P:fszmq.ZMQ.HANDSHAKE_IVL">
<summary>
 (Int32) The maximum handshake interval in milliseconds for the specified socket
</summary>
</member>
<member name="P:fszmq.ZMQ.GSSAPI_PLAINTEXT">
<summary>
 (Int32) 1 means that GSSAPI communication will be plaintext, 0 means communications will be encrypted
</summary>
</member>
<member name="P:fszmq.ZMQ.GSSAPI_SERVICE_PRINCIPAL">
<summary>
 (String) The name of the pricipal of the GSSAPI server to which a GSSAPI client intends to connect
</summary>
</member>
<member name="P:fszmq.ZMQ.GSSAPI_PRINCIPAL">
<summary>
 (String) The name of the pricipal for whom GSSAPI credentials should be acquired
</summary>
</member>
<member name="P:fszmq.ZMQ.GSSAPI_SERVER">
<summary>
 (Int32) 1 means the socket will act as GSSAPI server; 0 means the socket will act as GSSAPI client
</summary>
</member>
<member name="P:fszmq.ZMQ.CONNECT_RID">
<summary>
 (Byte[]) Sets the peer ID of the next connected host, and immediately 
 readies that connection for data transfer with the named ID
</summary>
</member>
<member name="P:fszmq.ZMQ.TOS">
<summary>
 (Int32) ToS field is typically used to specify a packets priority; 
 The availability of this option is dependent on intermediate network equipment
</summary>
</member>
<member name="P:fszmq.ZMQ.ROUTER_HANDOVER">
<summary>
 (Int32) 0 to reject clients which use an existing identity, 1 to transfer the connection
</summary>
</member>
<member name="P:fszmq.ZMQ.ZAP_DOMAIN">
<summary>
 (String) Sets authentication domain
</summary>
</member>
<member name="P:fszmq.ZMQ.CONFLATE">
<summary>
 (Int32) 1 to keep last message in queue (ignores high-water mark options), 0 otherwise
</summary>
</member>
<member name="P:fszmq.ZMQ.REQ_RELAXED">
<summary>
 (Int32) 1 to relax strict alternation between ZMQ.REQ and ZMQ.REP, 0 otherwise
</summary>
</member>
<member name="P:fszmq.ZMQ.REQ_CORRELATE">
<summary>
 (Int32) 1 to prefix messages with explicit request ID, 0 otherwise
</summary>
</member>
<member name="P:fszmq.ZMQ.PROBE_ROUTER">
<summary>
 (Int32) 1 to automatically send an empty message on new connection, 0 otherwise
</summary>
</member>
<member name="P:fszmq.ZMQ.CURVE_SERVERKEY">
<summary>
 (String or Byte[]) sets the long-term server key on a client socket
</summary>
</member>
<member name="P:fszmq.ZMQ.CURVE_SECRETKEY">
<summary>
 (String or Byte[]) sets the long-term secret key on a client socket
</summary>
</member>
<member name="P:fszmq.ZMQ.CURVE_PUBLICKEY">
<summary>
 (String or Byte[]) sets the long-term public key on a client or server socket
</summary>
</member>
<member name="P:fszmq.ZMQ.CURVE_SERVER">
<summary>
 (Int32) 1 to make socket act as server for CURVE security, 0 otherwise
</summary>
</member>
<member name="P:fszmq.ZMQ.PLAIN_PASSWORD">
<summary>
 (String) Sets the password for outgoing connections over TCP or IPC
</summary>
</member>
<member name="P:fszmq.ZMQ.PLAIN_USERNAME">
<summary>
 (String) Sets the user name for outgoing connections over TCP or IPC
</summary>
</member>
<member name="P:fszmq.ZMQ.PLAIN_SERVER">
<summary>
 (Int32) 1 to make socket act as server for PLAIN security, 0 otherwise
</summary>
</member>
<member name="P:fszmq.ZMQ.MECHANISM">
<summary>
 (Int32) Returns the current security mechanism
</summary>
</member>
<member name="P:fszmq.ZMQ.IPV6">
<summary>
 (Int32) 1 to enable IPv6 on the socket, 0 to restrict to only IPv4
</summary>
</member>
<member name="P:fszmq.ZMQ.XPUB_VERBOSE">
<summary>
 (Int32) 1 will resend duplicate messages
</summary>
</member>
<member name="P:fszmq.ZMQ.IMMEDIATE">
<summary>
 (Int32) 1 to limit queuing to only completed connections, 0 otherwise
</summary>
</member>
<member name="P:fszmq.ZMQ.TCP_KEEPALIVE_INTVL">
<summary>
 (Int32) Override OS-level TCP keep-alive
</summary>
</member>
<member name="P:fszmq.ZMQ.TCP_KEEPALIVE_IDLE">
<summary>
 (Int32) Override OS-level TCP keep-alive
</summary>
</member>
<member name="P:fszmq.ZMQ.TCP_KEEPALIVE_CNT">
<summary>
 (Int32) Override OS-level TCP keep-alive
</summary>
</member>
<member name="P:fszmq.ZMQ.TCP_KEEPALIVE">
<summary>
 (Int32) Override OS-level TCP keep-alive
</summary>
</member>
<member name="P:fszmq.ZMQ.ROUTER_MANDATORY">
<summary>
 (Int32) 1 to error on unroutable messages, 0 to silently ignore
</summary>
</member>
<member name="P:fszmq.ZMQ.LAST_ENDPOINT">
<summary>
 (String) Last address bound to endpoint
</summary>
</member>
<member name="P:fszmq.ZMQ.SNDTIMEO">
<summary>
 (Int32) Timeout period for outbound messages in milliseconds
</summary>
</member>
<member name="P:fszmq.ZMQ.RCVTIMEO">
<summary>
 (Int32) Timeout period for inbound messages in milliseconds
</summary>
</member>
<member name="P:fszmq.ZMQ.MULTICAST_HOPS">
<summary>
 (Int32) Time-to-live for each multicast packet in network-hops
</summary>
</member>
<member name="P:fszmq.ZMQ.RCVHWM">
<summary>
 (Int32) Maximum number of inbound queued messages
</summary>
</member>
<member name="P:fszmq.ZMQ.SNDHWM">
<summary>
 (Int32) Maximum number of outbound queued messages
</summary>
</member>
<member name="P:fszmq.ZMQ.MAXMSGSIZE">
<summary>
 (Int64) Maximum inbound message size in bytes
</summary>
</member>
<member name="P:fszmq.ZMQ.RECONNECT_IVL_MAX">
<summary>
 (Int32) Maximum reconnection interval in milliseconds
</summary>
</member>
<member name="P:fszmq.ZMQ.BACKLOG">
<summary>
 (Int32) Maximum number of queued peers
</summary>
</member>
<member name="P:fszmq.ZMQ.RECONNECT_IVL">
<summary>
 (Int32) Pause before reconnect in milliseconds
</summary>
</member>
<member name="P:fszmq.ZMQ.LINGER">
<summary>
 (Int32) Pause before shutdown in milliseconds
</summary>
</member>
<member name="P:fszmq.ZMQ.TYPE">
<summary>
 (Int32) Socket type
</summary>
</member>
<member name="P:fszmq.ZMQ.EVENTS">
<summary>
 (Int32) Socket event state, see all: Polling
</summary>
</member>
<member name="P:fszmq.ZMQ.FD">
<summary>
 (IntPtr) native file descriptor
</summary>
</member>
<member name="P:fszmq.ZMQ.RCVMORE">
<summary>
 (Int32) 1 if more message frames are available, 0 otherwise
</summary>
</member>
<member name="P:fszmq.ZMQ.RCVBUF">
<summary>
 (Int32) Receive-message buffer size in bytes
</summary>
</member>
<member name="P:fszmq.ZMQ.SNDBUF">
<summary>
 (Int32) Send-message buffer size in bytes
</summary>
</member>
<member name="P:fszmq.ZMQ.RECOVERY_IVL">
<summary>
 (Int32) Multicast recovery period in milliseconds
</summary>
</member>
<member name="P:fszmq.ZMQ.RATE">
<summary>
 (Int32) Multicast data rate in kilobits per second
</summary>
</member>
<member name="P:fszmq.ZMQ.UNSUBSCRIBE">
<summary>
 (Byte[]) Remove subscription filter
</summary>
</member>
<member name="P:fszmq.ZMQ.SUBSCRIBE">
<summary>
 (Byte[]) Add subscription filter
</summary>
</member>
<member name="P:fszmq.ZMQ.IDENTITY">
<summary>
 (Byte[]) Socket identifier
</summary>
</member>
<member name="P:fszmq.ZMQ.AFFINITY">
<summary>
 (UInt64) I/O thread affinity bit-mask
</summary>
</member>
<member name="P:fszmq.ZMQ.XREP">
<summary>
 Deprecated. Use ZMQ.ROUTER
</summary>
</member>
<member name="P:fszmq.ZMQ.XREQ">
<summary>
 Deprecated. Use ZMQ.DEALER
</summary>
</member>
<member name="P:fszmq.ZMQ.STREAM">
<summary>
 Exchanges raw data with a non-ZeroMQ peer via the tcp transport
</summary>
</member>
<member name="P:fszmq.ZMQ.XSUB">
<summary>
 A publisher like ZMQ.SUB, but does not automatically forward topic subscriptions
</summary>
</member>
<member name="P:fszmq.ZMQ.XPUB">
<summary>
 A publisher like ZMQ.PUB, but does not automatically receive forwarded topic subscriptions
</summary>
</member>
<member name="P:fszmq.ZMQ.PUSH">
<summary>
 Delivers messages in a round-robin fashion to across all downstream (i.e. ZMQ.PULL) nodes
</summary>
</member>
<member name="P:fszmq.ZMQ.PULL">
<summary>
 Collects messages in a fair-queued fashion from across all upstream (i.e. ZMQ.PUSH) nodes
</summary>
</member>
<member name="P:fszmq.ZMQ.ROUTER">
<summary>
 Participates in asynchronous request/reply exchanges with compatible peers (i.e. ZMQ.REQ, ZMQ.DEALER, ZMQ.ROUTER)
</summary>
</member>
<member name="P:fszmq.ZMQ.DEALER">
<summary>
 Participates in asynchronous request/reply exchanges with compatible peers (i.e. ZMQ.REP, ZMQ.DEALER, ZMQ.ROUTER)
</summary>
</member>
<member name="P:fszmq.ZMQ.REP">
<summary>
 Awaits synchronous requests of a client (i.e. ZMQ.REQ, ZMQ.DEALER), makes replies
</summary>
</member>
<member name="P:fszmq.ZMQ.REQ">
<summary>
 Makes synchronous requests of a server (i.e. ZMQ.REP, ZMQ.ROUTER), awaits replies
</summary>
</member>
<member name="P:fszmq.ZMQ.SUB">
<summary>
 A subscribe which receives topic-prefixed messages
</summary>
</member>
<member name="P:fszmq.ZMQ.PUB">
<summary>
 A publisher which broadcasts topic-prefixed messages
</summary>
</member>
<member name="P:fszmq.ZMQ.PAIR">
<summary>
 An exclusive pair of two sockets (primarily for use with inproc transport)
</summary>
</member>
<member name="P:fszmq.ZMQ.EVENT_ALL">
<summary>
 Monitor all possible events
</summary>
</member>
<member name="P:fszmq.ZMQ.EVENT_MONITOR_STOPPED">
<summary>
 Event monitoring has been disabled
</summary>
</member>
<member name="P:fszmq.ZMQ.EVENT_DISCONNECTED">
<summary>
 Broken session (specific to ipc and tcp transports)
</summary>
</member>
<member name="P:fszmq.ZMQ.EVENT_CLOSE_FAILED">
<summary>
 Connection could not be closed (only for ipc transport)
</summary>
</member>
<member name="P:fszmq.ZMQ.EVENT_CLOSED">
<summary>
 Socket connection closed
</summary>
</member>
<member name="P:fszmq.ZMQ.EVENT_ACCEPT_FAILED">
<summary>
 Could not accept client connection
</summary>
</member>
<member name="P:fszmq.ZMQ.EVENT_ACCEPTED">
<summary>
 Connection accepted to bound interface
</summary>
</member>
<member name="P:fszmq.ZMQ.EVENT_BIND_FAILED">
<summary>
 Socket could not bind to address
</summary>
</member>
<member name="P:fszmq.ZMQ.EVENT_LISTENING">
<summary>
 Socket bound to address; ready to accept connections
</summary>
</member>
<member name="P:fszmq.ZMQ.EVENT_CONNECT_RETRIED">
<summary>
 Asynchronous (re)connection attempt
</summary>
</member>
<member name="P:fszmq.ZMQ.EVENT_CONNECT_DELAYED">
<summary>
 Synchronous connection failed; socket is being polled
</summary>
</member>
<member name="P:fszmq.ZMQ.EVENT_CONNECTED">
<summary>
 Socket connection established
</summary>
</member>
<member name="P:fszmq.ZMQ.THREAD_SCHED_POLICY_DFLT">
<summary>
 Default thread scheduling policy (-1)
</summary>
</member>
<member name="P:fszmq.ZMQ.THREAD_PRIORITY_DFLT">
<summary>
 Default thread scheduling priority (-1)
</summary>
</member>
<member name="P:fszmq.ZMQ.MAX_SOCKETS_DFLT">
<summary>
 Default maximum number of sockets (1024)
</summary>
</member>
<member name="P:fszmq.ZMQ.IO_THREADS_DFLT">
<summary>
 Default number of OS-level I/O threads (1)
</summary>
</member>
<member name="P:fszmq.ZMQ.THREAD_SCHED_POLICY">
<summary>
 (Int32) Set thread scheduling policy (only valid on systems which use pthread)
</summary>
</member>
<member name="P:fszmq.ZMQ.THREAD_PRIORITY">
<summary>
 (Int32) Change thread scheduling priority (only valid on systems which use pthread)
</summary>
</member>
<member name="P:fszmq.ZMQ.SOCKET_LIMIT">
<summary>
 (Int32) Get largest configurable number of sockets
</summary>
</member>
<member name="P:fszmq.ZMQ.MAX_SOCKETS">
<summary>
 (Int32) Set maximum number of sockets for a context
</summary>
</member>
<member name="P:fszmq.ZMQ.IO_THREADS">
<summary>
 (Int32) Set number of OS-level I/O threads
</summary>
</member>
<member name="M:fszmq.ZMQ.|EAGAIN|_|(System.Int32)">
<summary>
 Non-blocking mode was requested and the message cannot be sent at the moment
</summary>
</member>
<member name="P:fszmq.ZMQ.CAP_GSSAPI">
<summary>
 Used to test if library supports the GSSAPI security mechanism
</summary>
</member>
<member name="P:fszmq.ZMQ.CAP_CURVE">
<summary>
 Used to test if library supports the CURVE security mechanism
</summary>
</member>
<member name="P:fszmq.ZMQ.CAP_NORM">
<summary>
 Used to test if library supports the NORM transport protocol
</summary>
</member>
<member name="P:fszmq.ZMQ.CAP_TIPC">
<summary>
 Used to test if library supports the TIPC transport protocol
</summary>
</member>
<member name="P:fszmq.ZMQ.CAP_PGM">
<summary>
 Used to test if library supports the PGM transport protocol
</summary>
</member>
<member name="P:fszmq.ZMQ.CAP_IPC">
<summary>
 Used to test if library supports the IPC transport protocol
</summary>
</member>
<member name="M:fszmq.ZMQ.Has(System.String)">
<summary>
 Tests if the underlying (native) ZMQ library supports a given capability
</summary>
</member>
<member name="P:fszmq.ZMQ.Version">
<summary>
 Version of the underlying (native) ZMQ library
</summary>
</member>
<member name="T:fszmq.ZMQ">
<summary>
 Contains commonly-used pre-defined ZMQ values
</summary>
</member>
<member name="M:fszmq.MessageModule.op_GreaterGreaterBar(fszmq.Socket,fszmq.Message)">
<summary>
 Operator equivalent to `Message.recv` (with arguments reversed)
</summary>
</member>
<member name="M:fszmq.MessageModule.op_BarLessLess(fszmq.Message,fszmq.Socket)">
<summary>
 Operator equivalent to `Message.recv`
</summary>
</member>
<member name="M:fszmq.MessageModule.Recv(fszmq.Message,fszmq.Socket)">
<summary>
 Updates the given `Message` instance with the next available message from a socket;
 If no message is received before RCVTIMEO expires, throws a TimeoutException
</summary>
</member>
<member name="M:fszmq.MessageModule.TryRecv(fszmq.Message,fszmq.Socket,System.Int32)">
<summary>
 Updates the given `Message` instance with the next available message from a socket, 
 returning true (or false) if the recv was successful (or should be re-tried)
</summary>
</member>
<member name="M:fszmq.MessageModule.op_PlusGreaterGreater(fszmq.Socket,fszmq.Message)">
<summary>
 Operator equivalent to `Message.sendMore` (with arguments reversed)
</summary>
</member>
<member name="M:fszmq.MessageModule.op_MinusGreaterGreater(fszmq.Message,fszmq.Socket)">
<summary>
 Operator equivalent to `Message.send` (with arguments reversed)
</summary>
</member>
<member name="M:fszmq.MessageModule.op_LessLessPlus(fszmq.Message,fszmq.Socket)">
<summary>
 Operator equivalent to `Message.sendMore`
</summary>
</member>
<member name="M:fszmq.MessageModule.op_LessLessMinus(fszmq.Socket,fszmq.Message)">
<summary>
 Operator equivalent to `Message.send`
</summary>
</member>
<member name="M:fszmq.MessageModule.SendMore(fszmq.Message,fszmq.Socket)">
<summary>
 Sends a message, indicating more messages will follow
</summary>
</member>
<member name="M:fszmq.MessageModule.Send(fszmq.Message,fszmq.Socket)">
<summary>
 Sends a message, indicating no more messages will follow
</summary>
</member>
<member name="M:fszmq.MessageModule.TrySend(fszmq.Message,fszmq.Socket,System.Int32)">
<summary>
 Sends a message, with the given flags, returning true (or false)
 if the send was successful (or should be re-tried)
</summary>
</member>
<member name="M:fszmq.MessageModule.Clone(fszmq.Message)">
<summary>
 Makes a new instance of the Message type, with an independent copy of the source content.
</summary>
</member>
<member name="M:fszmq.MessageModule.Move(fszmq.Message,fszmq.Message)">
 <summary>
 Moves the content from one message to another message.
 <para> No actual copying of message content is performed, target is simply updated to reference the new content.
 source becomes an empty message after calling `Message.move()`. The original content of target, if any,
 shall be released. To preseve the content of source, see `Message.copy()`.</para>
 </summary>
</member>
<member name="M:fszmq.MessageModule.Copy(fszmq.Message,fszmq.Message)">
 <summary>
 Copies the content from one message to another message.
 <para> Avoid modifying message content after a message has been copied,
 as this can result in undefined behavior.</para>
 </summary>
</member>
<member name="M:fszmq.MessageModule.TryGetMetadata(fszmq.Message,System.String,System.String@)">
<summary>
 For a given message, extracts the metadata associated with the given name,
 returning false if no metadata is present (for the given name)

 This function is named TryGetMetadata in compiled assemblies.
 If you are accessing the function from a language other than F#, or through reflection, use this name.
</summary>
</member>
<member name="M:fszmq.MessageModule.TryGetMetadata(fszmq.Message,System.String)">
<summary>
 For a given message, returns the metadata associated with the given name
 as an `Option&lt;string&gt;` where `None` indicates no metadata is present
</summary>
</member>
<member name="M:fszmq.MessageModule.IsMatch(fszmq.Message,fszmq.Message)">
<summary>
 Tests if two `Message` instances have the same size and data
</summary>
</member>
<member name="M:fszmq.MessageModule.HasMore(fszmq.Message)">
<summary>
 Returns true if the given message is a frame in a multi-part message and more frames are available
</summary>
</member>
<member name="M:fszmq.MessageModule.Size(fszmq.Message)">
<summary>
 Returns the size (in bytes) of the given Message
</summary>
</member>
<member name="M:fszmq.MessageModule.Data(fszmq.Message)">
<summary>
 Returns the content of the given Message
</summary>
</member>
<member name="M:fszmq.MessageModule.Configure(fszmq.Message,System.Collections.Generic.IEnumerable{System.Tuple{System.Int32,System.Int32}})">
<summary>
 Sets the given block of option values for the given Message
</summary>
</member>
<member name="M:fszmq.MessageModule.SetOption(fszmq.Message,System.Int32,System.Int32)">
<summary>
 Sets the given option value for the given Message
</summary>
</member>
<member name="M:fszmq.MessageModule.GetOption(fszmq.Message,System.Int32)">
<summary>
 Gets the value of the given option for the given Message
</summary>
</member>
<member name="T:fszmq.MessageModule">
<summary>
 Contains methods for working with Message instances
</summary>
</member>
<member name="M:fszmq.SocketModule.Monitor(fszmq.Socket,System.String,System.Int32)">
<summary>
 Creates a `ZMQ.PAIR` socket, bound to the given address, which broadcasts
 events for the given socket. These events should be consumed by another `ZMQ.PAIR` socket
 connected to the given address (preferably on a background thread).
</summary>
</member>
<member name="M:fszmq.SocketModule.RecvAll(fszmq.Socket)">
<summary>
 Retrieves all frames of the next available message
</summary>
</member>
<member name="M:fszmq.SocketModule.RecvMore(fszmq.Socket)">
<summary>
 Returns true if more message frames are available
</summary>
</member>
<member name="M:fszmq.SocketModule.Recv(fszmq.Socket)">
<summary>
 Waits for (and returns) the next available frame from a socket
 If no message is received before RCVTIMEO expires, throws a TimeoutException
</summary>
</member>
<member name="M:fszmq.SocketModule.TryRecv(fszmq.Socket,System.Int32,System.Int32,System.Byte[]@)">
<summary>
 Gets the next available frame from a socket, 
 returning false if the operation should be re-attempted

 This function is named TryRecv in compiled assemblies.
 If you are accessing the function from a language other than F#, or through reflection, use this name.
</summary>
</member>
<member name="M:fszmq.SocketModule.TryRecv(fszmq.Socket,System.Int32,System.Int32)">
<summary>
 Gets the next available frame from a socket, returning a frame option
 where None indicates the operation should be re-attempted
</summary>
</member>
<member name="M:fszmq.SocketModule.SendAll(fszmq.Socket,System.Collections.Generic.IEnumerable{System.Byte[]})">
<summary>
 Sends all frames of a given message
 If message is empty, sends a single empty frame for convenience
</summary>
</member>
<member name="M:fszmq.SocketModule.op_BarTwiddleGreater(System.Byte[],fszmq.Socket)">
<summary>
 Operator equivalent to `Socket.sendMore` (with arguments reversed)
</summary>
</member>
<member name="M:fszmq.SocketModule.op_BarGreaterGreater(System.Byte[],fszmq.Socket)">
<summary>
 Operator equivalent to `Socket.send` (with arguments reversed)
</summary>
</member>
<member name="M:fszmq.SocketModule.op_LessTwiddleBar(fszmq.Socket)">
<summary>
 Operator equivalent to `Socket.sendMore`
</summary>
</member>
<member name="M:fszmq.SocketModule.op_LessLessBar(fszmq.Socket)">
<summary>
 Operator equivalent to `Socket.send`
</summary>
</member>
<member name="M:fszmq.SocketModule.SendMore(fszmq.Socket,System.Byte[])">
<summary>
 Sends a frame (blocking), indicating more frames will follow, and returning the given socket
</summary>
</member>
<member name="M:fszmq.SocketModule.Send(fszmq.Socket,System.Byte[])">
<summary>
 Sends a frame (blocking), indicating no more frames will follow
</summary>
</member>
<member name="M:fszmq.SocketModule.TrySend(fszmq.Socket,System.Byte[],System.Int32)">
<summary>
 Sends a frame, with the given flags, returning true (or false)
 if the send was successful (or should be re-tried)
</summary>
</member>
<member name="M:fszmq.SocketModule.Unsubscribe(fszmq.Socket,System.Collections.Generic.IEnumerable{System.Byte[]})">
<summary>
 Removes one subscription for each of the given topics
</summary>
</member>
<member name="M:fszmq.SocketModule.Subscribe(fszmq.Socket,System.Collections.Generic.IEnumerable{System.Byte[]})">
<summary>
 Adds one subscription for each of the given topics
</summary>
</member>
<member name="M:fszmq.SocketModule.Configure(fszmq.Socket,System.Collections.Generic.IEnumerable{System.Tuple{System.Int32,System.Object}})">
<summary>
 Sets the given block of option values for the given Socket
</summary>
</member>
<member name="M:fszmq.SocketModule.SetOption``1(fszmq.Socket,System.Int32,``0)">
<summary>
 Sets the given option value for the given Socket
</summary>
</member>
<member name="M:fszmq.SocketModule.GetOption``1(fszmq.Socket,System.Int32)">
<summary>
 Gets the value of the given option for the given Socket
</summary>
</member>
<member name="M:fszmq.SocketModule.GetOption``1(fszmq.Socket,System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Int32})">
<summary>
 Gets the value of the given option for the given Socket
</summary>
</member>
<member name="M:fszmq.SocketModule.Disconnect(fszmq.Socket,System.String)">
<summary>
 Disconnects to an endpoint from the given address
</summary>
</member>
<member name="M:fszmq.SocketModule.Connect(fszmq.Socket,System.String)">
<summary>
 Connects to an endpoint to the given address
</summary>
</member>
<member name="M:fszmq.SocketModule.Unbind(fszmq.Socket,System.String)">
<summary>
 Causes an endpoint to stop accepting
 connections at the given address
</summary>
</member>
<member name="M:fszmq.SocketModule.Bind(fszmq.Socket,System.String)">
<summary>
 Causes an endpoint to start accepting
 connections at the given address
</summary>
</member>
<member name="T:fszmq.SocketModule">
<summary>
 Contains methods for working with Socket instances
</summary>
</member>
<member name="M:fszmq.Monitor.RecvEvent(fszmq.Socket)">
<summary>
 Receives the next ZMQEvent from a monitor socket;
 will raise exception if called on a non-monitor socket
</summary>
</member>
<member name="M:fszmq.Monitor.TryRecvEvent(fszmq.Socket)">
<summary>
 Tries to receive the next ZMQEvent from a monitor socket
</summary>
</member>
<member name="M:fszmq.Monitor.BuildEvent(System.Byte[][])">
<summary>
 Constructs a ZMQEvent from a raw (binary) message;
 will raise exception if message format is incorrect
</summary>
</member>
<member name="M:fszmq.Monitor.TryBuildEvent(System.Byte[][])">
<summary>
 Constructs a ZMQEvent option from a raw (binary) message
</summary>
</member>
<member name="T:fszmq.Monitor">
<summary>
 Contains methods for working with Socket diagnostics
</summary>
</member>
<member name="M:fszmq.ContextModule.Configure(fszmq.Context,System.Collections.Generic.IEnumerable{System.Tuple{System.Int32,System.Int32}})">
<summary>
 Sets the given block of option values for the given Context
</summary>
</member>
<member name="M:fszmq.ContextModule.SetOption(fszmq.Context,System.Int32,System.Int32)">
<summary>
 Sets the given option value for the given Context
</summary>
</member>
<member name="M:fszmq.ContextModule.GetOption(fszmq.Context,System.Int32)">
<summary>
 Gets the value of the given option for the given Context
</summary>
</member>
<member name="M:fszmq.ContextModule.Stream(fszmq.Context)">
 <summary>
 Creates a socket which can, asynchronously, send data to or
 receive data from an non-ZeroMQ peer (via the "TCP" transport).
 <para> Note: each message should begin with a peer identity. </para>
 <para> Additionally, a `ZMQ.STREAM` socket can act as client or a server.
 When acting as a server, the socket MUST set the `ZMQ.SENDMORE` flag.
 When acting as a client, the `ZMQ.SENDMORE` flag is ignored.
 Sending an identity followed by an empty frame, closes the connection.</para>
 </summary>
</member>
<member name="M:fszmq.ContextModule.XSub(fszmq.Context)">
 <summary>
 Behaves the same as a subscriber, except topical filtering is done
 by sending subscription messages to the publisher.
 <para> Subscriptions are made by sending a subscription message,
 in which the first byte is 1 or 0 (subscribe or unsubscribe)
 and the remainder of the message is the topic</para>
 </summary>
</member>
<member name="M:fszmq.ContextModule.XPub(fszmq.Context)">
<summary>
 Behaves the same as a publisher, except this socket type may also receive
 subscription messages from peers.

 **Note: topical filtering will be done at the publisher (before sending messages)**
</summary>
</member>
<member name="M:fszmq.ContextModule.Sub(fszmq.Context)">
 <summary>
 Creates a subscriber to receive to data distributed by a publisher.
 <para> Initially a `ZMQ.SUB` socket is not subscribed to any messages
 (i.e. one, or more, subscriptions must be applied, via `Socket.setOption`,
 before any messages will be received).</para>
 </summary>
</member>
<member name="M:fszmq.ContextModule.Pub(fszmq.Context)">
 <summary>
 Creates a publisher used to distribute messages to subscribers.

 **Note: topical filtering will be done at the subscriber (after receiving messages)**
 </summary>
</member>
<member name="M:fszmq.ContextModule.Push(fszmq.Context)">
<summary>
 Creates a pipeline node to send messages to downstream (`ZMQ.PULL`) nodes.
</summary>
</member>
<member name="M:fszmq.ContextModule.Pull(fszmq.Context)">
<summary>
 Creates a pipeline node to receive messages from upstream (`ZMQ.PUSH`) nodes.
</summary>
</member>
<member name="M:fszmq.ContextModule.Router(fszmq.Context)">
 <summary>
 Creates an advanced socket type used for extending the request/reply
 pattern.
 <para> When receiving messages a `ZMQ.ROUTER` socket prepends a
 message part containing the identity of the originating peer. </para>
 <para> When sending messages a `ZMQ.ROUTER` socket removes the first
 part of the message and uses it to determine the identity of the recipient.</para>
 </summary>
</member>
<member name="M:fszmq.ContextModule.Dealer(fszmq.Context)">
 <summary>
 Creates an advanced socket type used for extending the request/reply
 pattern.
 <para> When a `ZMQ.DEALER` socket is connected to a `ZMQ.REP` socket,
 each message sent must consist of an empty message part, the
 delimiter, followed by one or more body parts.</para>
 </summary>
</member>
<member name="M:fszmq.ContextModule.Rep(fszmq.Context)">
 <summary>
 Creates a service to receive requests from and send replies to a
 client.
 <para> This socket type allows only an alternating sequence of
 `Socket.recv(reply)` followed by `Socket.send(request)` calls.</para>
 </summary>
</member>
<member name="M:fszmq.ContextModule.Req(fszmq.Context)">
 <summary>
 Creates a client for sending requests to and receiving replies from
 a service.
 <para> This socket type allows only an alternating sequence of
 `Socket.send(request)` followed by `Socket.recv(reply)` calls.</para>
 </summary>
</member>
<member name="M:fszmq.ContextModule.Pair(fszmq.Context)">
 <summary>
 Creates a peer connected to exactly one other peer.
 <para> This socket type is used primarily for inter-thread
 communication across the "inproc" transport.</para>
 </summary>
</member>
<member name="M:fszmq.ContextModule.Socket(fszmq.Context,System.Int32)">
<summary>
 Creates a Socket, of the given type, within the given context
</summary>
</member>
<member name="T:fszmq.ContextModule">
<summary>
 Contains methods for working with Context instances
</summary>
</member>
<member name="M:fszmq.PollingModule.TryPollInput``1(System.Int64,fszmq.Socket)">
<summary>
 Polls the given socket, up to the given timeout, for an input message.
 Returns a byte[][] option, where None indicates no message was received.
</summary>
</member>
<member name="M:fszmq.PollingModule.PollForever(System.Collections.Generic.IEnumerable{fszmq.Poll})">
<summary>
 Calls `Polling.poll` with the given sequence of Poll items and no timeout,
 effectively causing the polling loop to block indefinitely.
</summary>
</member>
<member name="M:fszmq.PollingModule.PollNow(System.Collections.Generic.IEnumerable{fszmq.Poll})">
<summary>
 Calls `Polling.poll` with the given sequence of Poll items and 0 microseconds timeout
</summary>
</member>
<member name="M:fszmq.PollingModule.DoPoll``1(System.Int64,System.Collections.Generic.IEnumerable{fszmq.Poll})">
<summary>
 Performs a single polling run
 across the given sequence of Poll items, waiting up to the given timeout.
 Returns true when one or more callbacks have been invoked, returns false otherwise.

 ** Note: All items passed to Polling.poll MUST share the same context
 and belong to the thread calling `Polling.poll`. **

 This function is named DoPoll in compiled assemblies.
 If you are accessing the function from a language other than F#, or through reflection, use this name.
</summary>
</member>
<member name="M:fszmq.PollingModule.PollIO(Microsoft.FSharp.Core.FSharpFunc{fszmq.Socket,Microsoft.FSharp.Core.Unit},fszmq.Socket)">
<summary>
 Creates a Poll item for the socket which will
 invoke the callback when the socket sends or receives messages

</summary>
</member>
<member name="M:fszmq.PollingModule.PollOut(Microsoft.FSharp.Core.FSharpFunc{fszmq.Socket,Microsoft.FSharp.Core.Unit},fszmq.Socket)">
<summary>
 Creates a Poll item for the socket which will
 invoke the callback when the socket sends a message
</summary>
</member>
<member name="M:fszmq.PollingModule.PollIn(Microsoft.FSharp.Core.FSharpFunc{fszmq.Socket,Microsoft.FSharp.Core.Unit},fszmq.Socket)">
<summary>
 Creates a Poll item for the socket which will
 invoke the callback when the socket receives a message
</summary>
</member>
<member name="T:fszmq.PollingModule">
<summary>
 Contains methods for working with ZMQ&apos;s polling capabilities
</summary>
</member>
<member name="M:fszmq.Curve.MakeCurveKeyPair">
<summary>
 Returns a newly generated random keypair consisting of a public key and a secret key.
 The keys are encoded using ZeroMQ Base-85 Encoding.
</summary>
</member>
<member name="T:fszmq.Curve">
<summary>
 Utilities for working with the CurveZMQ security protocol
 (NOTE: required underlying library support for CurevZMQ)
</summary>
</member>
<member name="M:fszmq.Z85.Decode(System.String)">
<summary>
 Decodes ZeroMQ Base-85 encoded string to a binary block.

 ** Note: the size of the string MUST be divisible be 5. **
</summary>
</member>
<member name="M:fszmq.Z85.Encode(System.Byte[])">
<summary>
 Encodes a binary block into a string using ZeroMQ Base-85 Encoding.

 ** Note: the size of the binary block MUST be divisible be 4. **
</summary>
</member>
<member name="T:fszmq.Z85">
<summary>
 Utilities for working with ZeroMQ Base-85 Encoding
</summary>
</member>
<member name="M:fszmq.ProxyingModule.SteerableProxy(fszmq.Socket,fszmq.Socket,Microsoft.FSharp.Core.FSharpOption{fszmq.Socket},Microsoft.FSharp.Core.FSharpOption{fszmq.Socket})">
<summary>
 creates a proxy connection passing messages between two sockets,
 with an (optional) third socket for supplemental data capture,
 and an (optional) fourth socket for PAUSE/RESUME/TERMINATE control
</summary>
</member>
<member name="M:fszmq.ProxyingModule.Proxy(fszmq.Socket,fszmq.Socket,Microsoft.FSharp.Core.FSharpOption{fszmq.Socket})">
<summary>
 creates a proxy connection passing messages between two sockets,
 with an (optional) third socket for supplemental data capture
</summary>
</member>
<member name="T:fszmq.ProxyingModule">
<summary>
 Contains methods for working with ZMQ&apos;s proxying capabilities
</summary>
</member>
<member name="T:fszmq.Options.SocketOption.GssapiClientUnencripted">
<summary>
 Make socket act as a GSSAPI client, disabling encryption.
</summary>
</member>
<member name="T:fszmq.Options.SocketOption.GssapiServerUnencripted">
<summary>
 Make socket act as a GSSAPI server, disabling encryption.
</summary>
</member>
<member name="T:fszmq.Options.SocketOption.GssapiClient">
<summary>
 Make socket act as a GSSAPI client.
</summary>
</member>
<member name="T:fszmq.Options.SocketOption.GssapiServer">
<summary>
 Make socket act as a GSSAPI server.
</summary>
</member>
<member name="T:fszmq.Options.SocketOption.CurveClient">
<summary>
 Public and private keys for client using CURVE security
</summary>
</member>
<member name="T:fszmq.Options.SocketOption.CurveServer">
<summary>
 Make socket act as a server for CURVE security
</summary>
</member>
<member name="T:fszmq.Options.SocketOption.PlainClient">
<summary>
 Set user name and password for client using PLAIN security
</summary>
</member>
<member name="T:fszmq.Options.SocketOption.PlainServer">
<summary>
 make socket act as server for PLAIN security
</summary>
</member>
<member name="T:fszmq.Options.SocketOption.NullSecurity">
<summary>
 make socket act as server or client for NULL security
</summary>
</member>
<member name="T:fszmq.Options.SocketOption.DoNoSilentlyDropMessages">
<summary>
 do not silently drop messages if sending high water mark is reached
</summary>
</member>
<member name="T:fszmq.Options.SocketOption.SocksProxy">
<summary>
 Connect through a SOCKS proxy
</summary>
</member>
<member name="T:fszmq.Options.SocketOption.ConnectPeerId">
<summary>
 Sets the peer id of the next connected host, and immediately readies that connection for data transfer with the named id.
</summary>
</member>
<member name="T:fszmq.Options.SocketOption.TypeOfService">
<summary>
 Sets the ToS fields (Differentiated services (DS) and Explicit Congestion Notification (ECN) field of the IP header. The ToS field is typically used to specify a packets priority. 
</summary>
</member>
<member name="T:fszmq.Options.SocketOption.RouterHandover">
<summary>
 If that option is set, the ROUTER socket shall hand-over the connection to the new client and disconnect the existing one.
</summary>
</member>
<member name="T:fszmq.Options.SocketOption.HandshakeInterval">
<summary>
 Sets the maximum handshake interval
</summary>
</member>
<member name="T:fszmq.Options.SocketOption.AuthenticationDomain">
<summary>
 Sets authentication domain
</summary>
</member>
<member name="T:fszmq.Options.SocketOption.KeepLastMessageInQueue">
<summary>
 keep last message in queue (ignores high-water mark options)
</summary>
</member>
<member name="T:fszmq.Options.SocketOption.RelaxStrictAlternation">
<summary>
 relax strict alternation between ZMQ.REQ and ZMQ.REP
</summary>
</member>
<member name="T:fszmq.Options.SocketOption.RequestCorrelation">
<summary>
 prefix messages with explicit request ID
</summary>
</member>
<member name="T:fszmq.Options.SocketOption.ProbeRouter">
<summary>
 automatically send an empty message on new connection
</summary>
</member>
<member name="T:fszmq.Options.SocketOption.Ipv6">
<summary>
 true to enable IPv6 on the socket, false to restrict to only IPv4
</summary>
</member>
<member name="T:fszmq.Options.SocketOption.ResendDuplicateMessages">
<summary>
 resend duplicate messages
</summary>
</member>
<member name="T:fszmq.Options.SocketOption.Immediate">
<summary>
 limit queuing to only completed connections
</summary>
</member>
<member name="T:fszmq.Options.SocketOption.TcpKeepaliveInterval">
<summary>
 Override OS-level TCP keep-alive
</summary>
</member>
<member name="T:fszmq.Options.SocketOption.TcpKeepaliveIdle">
<summary>
 Override OS-level TCP keep-alive
</summary>
</member>
<member name="T:fszmq.Options.SocketOption.TcpKeepaliveCount">
<summary>
 Override OS-level TCP keep-alive
</summary>
</member>
<member name="T:fszmq.Options.SocketOption.TcpKeepalive">
<summary>
 Override OS-level TCP keep-alive
</summary>
</member>
<member name="T:fszmq.Options.SocketOption.RouterMandatory">
<summary>
 true to error on unroutable messages, false to silently ignore
</summary>
</member>
<member name="T:fszmq.Options.SocketOption.SendTimeout">
<summary>
 Timeout period for outbound messages
</summary>
</member>
<member name="T:fszmq.Options.SocketOption.ReceiveTimeout">
<summary>
 Timeout period for inbound messages
</summary>
</member>
<member name="T:fszmq.Options.SocketOption.MulticastHops">
<summary>
 Time-to-live for each multicast packet
</summary>
</member>
<member name="T:fszmq.Options.SocketOption.ReceiveQueue">
<summary>
 Maximum number of inbound queued messages
</summary>
</member>
<member name="T:fszmq.Options.SocketOption.SendQueue">
<summary>
 Maximum number of outbound queued messages
</summary>
</member>
<member name="T:fszmq.Options.SocketOption.MaxMessageSize">
<summary>
 Maximum inbound message size
</summary>
</member>
<member name="T:fszmq.Options.SocketOption.MaxReconnectInterval">
<summary>
 Maximum reconnection interval
</summary>
</member>
<member name="T:fszmq.Options.SocketOption.Backlog">
<summary>
 Maximum number of queued peers
</summary>
</member>
<member name="T:fszmq.Options.SocketOption.ReconnectDelay">
<summary>
 Pause before reconnect
</summary>
</member>
<member name="T:fszmq.Options.SocketOption.LingerDelay">
<summary>
 Pause before shutdown
</summary>
</member>
<member name="T:fszmq.Options.SocketOption.ReceiveBuffer">
<summary>
 Receive-message buffer size in bytes
</summary>
</member>
<member name="T:fszmq.Options.SocketOption.SendBuffer">
<summary>
 Send-message buffer size in bytes
</summary>
</member>
<member name="T:fszmq.Options.SocketOption.MulticastRecovery">
<summary>
 Multicast recovery period
</summary>
</member>
<member name="T:fszmq.Options.SocketOption.Rate">
<summary>
 Multicast data rate
</summary>
</member>
<member name="T:fszmq.Options.SocketOption.Unsubscribe">
<summary>
 Remove subscription filter
</summary>
</member>
<member name="T:fszmq.Options.SocketOption.Subscribe">
<summary>
 Add subscription filter
</summary>
</member>
<member name="T:fszmq.Options.SocketOption.Identity">
<summary>
 Socket identifier
</summary>
</member>
<member name="T:fszmq.Options.SocketOption.Affinity">
<summary>
 I/O thread affinity bit-mask
</summary>
</member>
<member name="T:fszmq.Options.SocketOption">
<summary>
 Settable socket options
</summary>
</member>
<member name="T:fszmq.Options.hop">
<summary>
 abbreviation for `NetworkHop`
</summary>
</member>
<member name="T:fszmq.Options.NetworkHop">
<summary>
 unit of travel from one network switch to another
</summary>
</member>
<member name="T:fszmq.Options.B">
<summary>
 abbreviation for `Byte`
</summary>
</member>
<member name="T:fszmq.Options.Byte">
<summary>
 8 bits
</summary>
</member>
<member name="T:fszmq.Options.ms">
<summary>
 abbreviation for `milliecond`
</summary>
</member>
<member name="T:fszmq.Options.millisecond">
<summary>
 1/1000th of a second
</summary>
</member>
<member name="T:fszmq.Options.s">
<summary>
 abbreviation for `second`
</summary>
</member>
<member name="T:fszmq.Options.second">
<summary>
 standard unit of time (1/60th of a minute)
</summary>
</member>
<member name="T:fszmq.Options.kb">
<summary>
 abbreviation for `kilobit`
</summary>
</member>
<member name="T:fszmq.Options.kilobit">
<summary>
 100 bits
</summary>
</member>
<member name="T:fszmq.Options.b">
<summary>
 abbreviation for `bit`
</summary>
</member>
<member name="T:fszmq.Options.bit">
<summary>
 binary unit of information
</summary>
</member>
<member name="M:fszmq.Options.SocketOptionModule.|GssapiClientUnencripted|_|(fszmq.Socket)">
<summary>
 true if the current security mechanism is GSSAPI and the socket is acting as a Client
</summary>
</member>
<member name="M:fszmq.Options.SocketOptionModule.|GssapiClient|_|(fszmq.Socket)">
<summary>
 true if the current security mechanism is GSSAPI and the socket is acting as a Client
</summary>
</member>
<member name="M:fszmq.Options.SocketOptionModule.|GssapiServerUnencripted|_|(fszmq.Socket)">
<summary>
 true if the current security mechanism is GSSAPI and the socket is acting as a server
</summary>
</member>
<member name="M:fszmq.Options.SocketOptionModule.|GssapiServer|_|(fszmq.Socket)">
<summary>
 true if the current security mechanism is GSSAPI and the socket is acting as a server
</summary>
</member>
<member name="M:fszmq.Options.SocketOptionModule.|SocksProxy|(fszmq.Socket)">
<summary>
 Retrieves SOCKS proxy address
</summary>
</member>
<member name="M:fszmq.Options.SocketOptionModule.|TypeOfService|(fszmq.Socket)">
<summary>
 Retrieves the TypeOfService option for the socket
</summary>
</member>
<member name="M:fszmq.Options.SocketOptionModule.|LastEndpointAddress|(fszmq.Socket)">
<summary>
 Retrieves the last endpoint bound for TCP and IPC transports
</summary>
</member>
<member name="M:fszmq.Options.SocketOptionModule.|CurveClient|_|(fszmq.Socket)">
<summary>
 true if the current security mechanism is CURVE and the socket is acting as a client
</summary>
</member>
<member name="M:fszmq.Options.SocketOptionModule.|CurveServer|_|(fszmq.Socket)">
<summary>
 true if the current security mechanism is CURVE and the socket is acting as a server
</summary>
</member>
<member name="M:fszmq.Options.SocketOptionModule.|AuthenticationDomain|(fszmq.Socket)">
<summary>
 Sets authentication domain
</summary>
</member>
<member name="M:fszmq.Options.SocketOptionModule.|KeepLastMessageInQueue|(fszmq.Socket)">
<summary>
 keep last message in queue (ignores high-water mark options)
</summary>
</member>
<member name="M:fszmq.Options.SocketOptionModule.|PlainClient|_|(fszmq.Socket)">
<summary>
 true if the current security mechanism is PLAIN and the socket is acting as a client
</summary>
</member>
<member name="M:fszmq.Options.SocketOptionModule.|PlainServer|_|(fszmq.Socket)">
<summary>
 true if the current security mechanism is PLAIN and the socket is acting as a server
</summary>
</member>
<member name="M:fszmq.Options.SocketOptionModule.|NullSecurity|_|(fszmq.Socket)">
<summary>
 true if the current security mechanism is NULL
</summary>
</member>
<member name="M:fszmq.Options.SocketOptionModule.|Ipv6|(fszmq.Socket)">
<summary>
 true to enable IPv6 on the socket, false to restrict to only IPv4
</summary>
</member>
<member name="M:fszmq.Options.SocketOptionModule.|Immediate|(fszmq.Socket)">
<summary>
 limit queuing to only completed connections
</summary>
</member>
<member name="M:fszmq.Options.SocketOptionModule.|HandshakeInterval|(fszmq.Socket)">
<summary>
 Retrieve the maximum handshake interval
</summary>
</member>
<member name="M:fszmq.Options.SocketOptionModule.|TcpKeepaliveInterval|(fszmq.Socket)">
<summary>
 Override OS-level TCP keep-alive
</summary>
</member>
<member name="M:fszmq.Options.SocketOptionModule.|TcpKeepaliveIdle|(fszmq.Socket)">
<summary>
 Override OS-level TCP keep-alive
</summary>
</member>
<member name="M:fszmq.Options.SocketOptionModule.|TcpKeepaliveCount|(fszmq.Socket)">
<summary>
 Override OS-level TCP keep-alive
</summary>
</member>
<member name="M:fszmq.Options.SocketOptionModule.|TcpKeepalive|(fszmq.Socket)">
<summary>
 `bool option` indicating state of TCP_KEEPALIVE; 
 `None` indicates system default value
</summary>
</member>
<member name="M:fszmq.Options.SocketOptionModule.|SendTimeout|(fszmq.Socket)">
<summary>
 Timeout period for outbound messages
</summary>
</member>
<member name="M:fszmq.Options.SocketOptionModule.|ReceiveTimeout|(fszmq.Socket)">
<summary>
 Timeout period for inbound messages
</summary>
</member>
<member name="M:fszmq.Options.SocketOptionModule.|MulticastHops|(fszmq.Socket)">
<summary>
 Time-to-live for each multicast packet
</summary>
</member>
<member name="M:fszmq.Options.SocketOptionModule.|ReceiveQueue|(fszmq.Socket)">
<summary>
 Maximum number of inbound queued messages
</summary>
</member>
<member name="M:fszmq.Options.SocketOptionModule.|SendQueue|(fszmq.Socket)">
<summary>
 Maximum number of outbound queued messages
</summary>
</member>
<member name="M:fszmq.Options.SocketOptionModule.|MaxMessageSize|(fszmq.Socket)">
<summary>
 Maximum inbound message size
</summary>
</member>
<member name="M:fszmq.Options.SocketOptionModule.|MaxReconnectInterval|(fszmq.Socket)">
<summary>
 Maximum reconnection interval
</summary>
</member>
<member name="M:fszmq.Options.SocketOptionModule.|Backlog|(fszmq.Socket)">
<summary>
 Maximum number of queued peers
</summary>
</member>
<member name="M:fszmq.Options.SocketOptionModule.|ReconnectDelay|(fszmq.Socket)">
<summary>
 Pause before reconnect
</summary>
</member>
<member name="M:fszmq.Options.SocketOptionModule.|LingerDelay|(fszmq.Socket)">
<summary>
 Pause before shutdown
</summary>
</member>
<member name="M:fszmq.Options.SocketOptionModule.|SocketType|(fszmq.Socket)">
<summary>
 Socket type
</summary>
</member>
<member name="M:fszmq.Options.SocketOptionModule.|Events|(fszmq.Socket)">
<summary>
 Socket event state, see all: Polling
</summary>
</member>
<member name="M:fszmq.Options.SocketOptionModule.|MoreMessageFramesAvailable|(fszmq.Socket)">
<summary>
 More message frames available
</summary>
</member>
<member name="M:fszmq.Options.SocketOptionModule.|ReceiveBuffer|(fszmq.Socket)">
<summary>
 Receive-message buffer size in bytes
</summary>
</member>
<member name="M:fszmq.Options.SocketOptionModule.|SendBuffer|(fszmq.Socket)">
<summary>
 Send-message buffer size in bytes
</summary>
</member>
<member name="M:fszmq.Options.SocketOptionModule.|MulticastRecovery|(fszmq.Socket)">
<summary>
 Multicast recovery period
</summary>
</member>
<member name="M:fszmq.Options.SocketOptionModule.|Rate|(fszmq.Socket)">
<summary>
 Multicast data rate
</summary>
</member>
<member name="M:fszmq.Options.SocketOptionModule.|Identity|(fszmq.Socket)">
<summary>
 Socket identifier
</summary>
</member>
<member name="M:fszmq.Options.SocketOptionModule.|Affinity|(fszmq.Socket)">
<summary>
 I/O thread affinity bit-mask
</summary>
</member>
<member name="M:fszmq.Options.SocketOptionModule.configureSocket(fszmq.Socket,System.Collections.Generic.IEnumerable{fszmq.Options.SocketOption})">
<summary>
 Sets all the given `SocketOption`s on the given `Socket`
</summary>
</member>
<member name="M:fszmq.Options.SocketOptionModule.setSocketOption(fszmq.Socket,fszmq.Options.SocketOption)">
<summary>
 Sets the given `SocketOption` on the given `Socket`
</summary>
</member>
<member name="T:fszmq.Options.SocketOptionModule">
<summary>
 Contains functions for configuring sockets and patterns for interogating sockets

 _(NOTE: this module is automatically opened when its parent module is opened.)_
</summary>
</member>
<member name="T:fszmq.Options">
<summary>
 Higher-level API for working with socket options
</summary>
</member>
</members>
</doc>
